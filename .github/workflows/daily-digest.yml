name: CEO Cockpit ‚Äî Daily Digest

on:
  schedule:
    # 06:00 BRT = 09:00 UTC, weekdays only
    - cron: '0 9 * * 1-5'
  workflow_dispatch:

permissions:
  issues: write
  contents: read
  pull-requests: read

jobs:
  daily-digest:
    runs-on: ubuntu-latest
    steps:
      - name: Generate CEO Cockpit Report
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            const since = yesterday.toISOString();

            const brtDate = now.toLocaleDateString('pt-BR', {
              timeZone: 'America/Sao_Paulo',
              weekday: 'long',
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            });

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // === SECTION 1: Project Board Data via GraphQL ===
            const PROJECT_NUMBER = 2;
            let projectItems = [];
            try {
              const result = await github.graphql(`
                query($owner: String!, $number: Int!) {
                  user(login: $owner) {
                    projectV2(number: $number) {
                      items(first: 100) {
                        nodes {
                          fieldValues(first: 20) {
                            nodes {
                              ... on ProjectV2ItemFieldSingleSelectValue {
                                name
                                field { ... on ProjectV2SingleSelectField { name } }
                              }
                              ... on ProjectV2ItemFieldTextValue {
                                text
                                field { ... on ProjectV2FieldCommon { name } }
                              }
                            }
                          }
                          content {
                            ... on Issue {
                              number
                              title
                              url
                              state
                              labels(first: 10) {
                                nodes { name }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `, { owner, number: PROJECT_NUMBER });

              projectItems = result.user.projectV2.items.nodes
                .filter(item => item.content && item.content.number)
                .map(item => {
                  const fields = {};
                  for (const fv of item.fieldValues.nodes) {
                    if (fv.field && fv.field.name) {
                      fields[fv.field.name] = fv.name || fv.text || '';
                    }
                  }
                  return {
                    number: item.content.number,
                    title: item.content.title,
                    url: item.content.url,
                    state: item.content.state,
                    labels: item.content.labels.nodes.map(l => l.name),
                    ...fields
                  };
                });
            } catch (e) {
              console.log(`Project query failed: ${e.message}`);
            }

            // === SECTION 2: Counts by Status ===
            const statusCounts = {};
            const agentCounts = {};
            const domainCounts = {};
            const priorityCounts = {};
            const blockedItems = [];
            const tonightItems = [];
            const runningItems = [];
            const reviewItems = [];

            for (const item of projectItems) {
              const status = item.Status || 'Unknown';
              const agent = item.Agent || '‚Äî';
              const domain = item.Domain || '‚Äî';
              const priority = item.Priority || '‚Äî';

              statusCounts[status] = (statusCounts[status] || 0) + 1;
              agentCounts[agent] = (agentCounts[agent] || 0) + 1;
              domainCounts[domain] = (domainCounts[domain] || 0) + 1;
              priorityCounts[priority] = (priorityCounts[priority] || 0) + 1;

              if (status.includes('Blocked')) blockedItems.push(item);
              if (status.includes('Tonight')) tonightItems.push(item);
              if (status.includes('Running')) runningItems.push(item);
              if (status.includes('Review')) reviewItems.push(item);
            }

            // === SECTION 3: Commits in last 24h ===
            let commits = [];
            try {
              const { data } = await github.rest.repos.listCommits({
                owner, repo, since, per_page: 20
              });
              commits = data;
            } catch (e) {
              console.log('No commits found');
            }

            // === SECTION 4: PRs merged in last 24h ===
            let mergedPRs = [];
            try {
              const { data } = await github.rest.pulls.list({
                owner, repo, state: 'closed', sort: 'updated', direction: 'desc', per_page: 20
              });
              mergedPRs = data.filter(pr =>
                pr.merged_at && new Date(pr.merged_at) > yesterday
              );
            } catch (e) {
              console.log('No merged PRs found');
            }

            // === SECTION 5: Issues opened/closed in last 24h ===
            let openedIssues = [];
            let closedIssues = [];
            try {
              const { data } = await github.rest.issues.listForRepo({
                owner, repo, state: 'all', since, sort: 'updated', direction: 'desc', per_page: 50
              });
              const issues = data.filter(i => !i.pull_request);
              openedIssues = issues.filter(i => new Date(i.created_at) > yesterday);
              closedIssues = issues.filter(i => i.closed_at && new Date(i.closed_at) > yesterday);
            } catch (e) {
              console.log('No issues found');
            }

            // === SECTION 6: Decision queue ===
            let decisionIssues = [];
            try {
              const { data } = await github.rest.issues.listForRepo({
                owner, repo, state: 'open', labels: 'status:needs-decision', per_page: 20
              });
              decisionIssues = data.filter(i => !i.pull_request);
            } catch (e) {
              console.log('No decision issues found');
            }

            // === BUILD REPORT ===
            let body = `# CEO Cockpit ‚Äî ${brtDate}\n\n`;

            // --- Board Summary ---
            body += `## Board Summary\n\n`;
            body += `| Status | Count |\n|--------|-------|\n`;
            const statusOrder = ['üöÄ Roadmap', 'üß† Backlog', 'üåô Tonight', '‚öôÔ∏è Running', 'üîç Review', '‚úÖ Done', '‚õî Blocked'];
            for (const s of statusOrder) {
              if (statusCounts[s]) {
                body += `| ${s} | ${statusCounts[s]} |\n`;
              }
            }
            body += `\n`;

            // --- By Agent ---
            body += `**By Agent:**`;
            const agentEntries = Object.entries(agentCounts).sort((a, b) => b[1] - a[1]);
            for (const [agent, count] of agentEntries) {
              body += ` ${agent} (${count})`;
            }
            body += `\n\n`;

            // --- By Priority ---
            body += `**By Priority:**`;
            for (const p of ['P0', 'P1', 'P2']) {
              if (priorityCounts[p]) body += ` ${p} (${priorityCounts[p]})`;
            }
            body += `\n\n`;

            // --- Tonight Queue ---
            body += `## üåô Tonight Queue (${tonightItems.length})\n\n`;
            if (tonightItems.length === 0) {
              body += `_Nenhuma issue programada para tonight_\n\n`;
            } else {
              for (const item of tonightItems) {
                body += `- [#${item.number}](${item.url}) ${item.title} ‚Äî **${item.Agent || '‚Äî'}** (${item.Priority || '‚Äî'})\n`;
              }
              body += `\n`;
            }

            // --- Running ---
            if (runningItems.length > 0) {
              body += `## ‚öôÔ∏è Running (${runningItems.length})\n\n`;
              for (const item of runningItems) {
                body += `- [#${item.number}](${item.url}) ${item.title} ‚Äî **${item.Agent || '‚Äî'}**\n`;
              }
              body += `\n`;
            }

            // --- Review ---
            if (reviewItems.length > 0) {
              body += `## üîç Review (${reviewItems.length})\n\n`;
              for (const item of reviewItems) {
                body += `- [#${item.number}](${item.url}) ${item.title}\n`;
              }
              body += `\n`;
            }

            // --- Blockers ---
            body += `## ‚õî Blockers (${blockedItems.length})\n\n`;
            if (blockedItems.length === 0) {
              body += `_Nenhum blocker ativo_\n\n`;
            } else {
              for (const item of blockedItems) {
                const statusLabels = item.labels
                  .filter(l => l.startsWith('status:'))
                  .map(l => `\`${l}\``)
                  .join(' ');
                body += `- [#${item.number}](${item.url}) ${item.title} ${statusLabels}\n`;
              }
              body += `\n`;
            }

            // --- Decisions ---
            body += `## Decis√µes Pendentes (${decisionIssues.length})\n\n`;
            if (decisionIssues.length === 0) {
              body += `_Nenhuma decis√£o pendente_\n\n`;
            } else {
              for (const i of decisionIssues) {
                body += `- [#${i.number}](${i.html_url}) ${i.title}\n`;
              }
              body += `\n`;
            }

            // --- Issues movidas (opened/closed) ---
            body += `## Movimenta√ß√£o 24h\n\n`;
            body += `**Issues abertas:** ${openedIssues.length} | **Issues fechadas:** ${closedIssues.length}\n\n`;
            if (openedIssues.length > 0) {
              for (const i of openedIssues) {
                body += `- üÜï [#${i.number}](${i.html_url}) ${i.title}\n`;
              }
            }
            if (closedIssues.length > 0) {
              for (const i of closedIssues) {
                body += `- ‚úÖ [#${i.number}](${i.html_url}) ${i.title}\n`;
              }
            }
            if (openedIssues.length === 0 && closedIssues.length === 0) {
              body += `_Nenhuma movimenta√ß√£o_\n`;
            }
            body += `\n`;

            // --- Commits & PRs ---
            body += `## Commits & PRs\n\n`;
            body += `**Commits (${commits.length}):**\n`;
            if (commits.length === 0) {
              body += `_Nenhum commit nas √∫ltimas 24h_\n`;
            } else {
              for (const c of commits.slice(0, 10)) {
                const msg = c.commit.message.split('\n')[0];
                const sha = c.sha.substring(0, 7);
                body += `- [\`${sha}\`](${c.html_url}) ${msg}\n`;
              }
              if (commits.length > 10) body += `- _... e mais ${commits.length - 10}_\n`;
            }
            body += `\n`;

            body += `**PRs Merged (${mergedPRs.length}):**\n`;
            if (mergedPRs.length === 0) {
              body += `_Nenhum PR merged_\n`;
            } else {
              for (const pr of mergedPRs) {
                body += `- [#${pr.number}](${pr.html_url}) ${pr.title}\n`;
              }
            }
            body += `\n`;

            // --- Metrics ---
            const doneCount = statusCounts['‚úÖ Done'] || 0;
            const wipCount = (statusCounts['‚öôÔ∏è Running'] || 0) + (statusCounts['üîç Review'] || 0);
            const totalOpen = projectItems.filter(i => i.state === 'OPEN').length;

            body += `## M√©tricas\n\n`;
            body += `| M√©trica | Valor |\n|---------|-------|\n`;
            body += `| Done (total) | ${doneCount} |\n`;
            body += `| WIP (Running + Review) | ${wipCount} |\n`;
            body += `| Blocked | ${blockedItems.length} |\n`;
            body += `| Tonight Queue | ${tonightItems.length} |\n`;
            body += `| Total Open | ${totalOpen} |\n`;
            body += `| Closed 24h | ${closedIssues.length} |\n`;
            body += `\n`;

            // === CEO ACTION ITEMS ===
            body += `## üéØ A√ß√µes Sugeridas para Hoje\n\n`;

            const actions = [];

            // 1. Blocked items need attention
            if (blockedItems.length > 0) {
              const blockedP0 = blockedItems.filter(i => i.Priority === 'P0');
              if (blockedP0.length > 0) {
                actions.push(`üî¥ **Desbloquear P0:** ${blockedP0.map(i => `#${i.number}`).join(', ')} est√£o blocked e s√£o cr√≠ticas. Resolver antes de qualquer outra coisa.`);
              } else {
                actions.push(`üü° **Resolver blockers:** ${blockedItems.map(i => `#${i.number}`).join(', ')} precisam de a√ß√£o (decis√£o, contato externo, ou config).`);
              }
            }

            // 2. Tonight queue health
            if (tonightItems.length === 0) {
              const backlogP0 = projectItems.filter(i =>
                (i.Status || '').includes('Backlog') && i.Priority === 'P0'
              );
              const backlogP1 = projectItems.filter(i =>
                (i.Status || '').includes('Backlog') && i.Priority === 'P1' && i.Agent === 'Builder'
              );
              const candidates = [...backlogP0, ...backlogP1].slice(0, 3);
              if (candidates.length > 0) {
                actions.push(`üåô **Tonight vazio!** Mover para Tonight: ${candidates.map(i => `#${i.number} (${i.Priority})`).join(', ')}`);
              }
            } else if (tonightItems.length > 5) {
              actions.push(`‚ö†Ô∏è **Tonight sobrecarregado** (${tonightItems.length} items). Capacidade ideal: 2-4 por noite. Priorize os P0.`);
            }

            // 3. Review items waiting
            if (reviewItems.length > 0) {
              actions.push(`üîç **Revisar:** ${reviewItems.map(i => `#${i.number}`).join(', ')} aguardam sua aprova√ß√£o.`);
            }

            // 4. Decision queue
            if (decisionIssues.length > 0) {
              actions.push(`üß† **Decidir:** ${decisionIssues.map(i => `#${i.number} ${i.title}`).join(', ')}`);
            }

            // 5. WIP limit
            if (wipCount > 3) {
              actions.push(`‚ö†Ô∏è **WIP alto (${wipCount}).** Terminar antes de come√ßar. Foco em mover Running ‚Üí Review ‚Üí Done.`);
            }

            // 6. No done in 24h
            if (closedIssues.length === 0 && doneCount > 0) {
              actions.push(`üìä **Zero issues fechadas ontem.** Verificar se algo travou ou se escopos est√£o grandes demais.`);
            }

            if (actions.length === 0) {
              actions.push(`‚úÖ **Tudo fluindo bem.** Board saud√°vel, sem a√ß√µes urgentes.`);
            }

            for (const action of actions) {
              body += `${action}\n\n`;
            }

            // === FOCO DO DIA ===
            body += `## üèÜ Foco do Dia ‚Äî Onde Gerar Mais Valor\n\n`;

            // Identify highest-value focus
            const p0Open = projectItems.filter(i =>
              i.state === 'OPEN' && i.Priority === 'P0' && !(i.Status || '').includes('Blocked')
            );
            const p0Blocked = projectItems.filter(i =>
              i.Priority === 'P0' && (i.Status || '').includes('Blocked')
            );

            if (p0Blocked.length > 0 && p0Open.length <= 2) {
              body += `**Desbloquear > Construir.** Com ${p0Blocked.length} P0 blocked, o maior valor hoje √© resolver impedimentos:\n`;
              for (const item of p0Blocked) {
                const reason = item.labels.filter(l => l.startsWith('status:')).join(', ') || 'verificar motivo';
                body += `- #${item.number} ${item.title} ‚Äî _${reason}_\n`;
              }
            } else if (p0Open.length > 0) {
              body += `**Executar P0s.** ${p0Open.length} issues P0 abertas e desbloqueadas:\n`;
              for (const item of p0Open.slice(0, 5)) {
                body += `- #${item.number} ${item.title} (${item.Status || '‚Äî'})\n`;
              }
            } else {
              body += `**Todos os P0 resolvidos ou em progresso.** Avan√ßar nos P1 do sprint.\n`;
            }
            body += `\n`;

            // === TONIGHT RECOMMENDATION ===
            body += `## üåô Recomenda√ß√£o para Tonight\n\n`;
            const backlogReady = projectItems.filter(i =>
              i.state === 'OPEN' &&
              (i.Status || '').includes('Backlog') &&
              (i.Priority === 'P0' || i.Priority === 'P1') &&
              i.Agent === 'Builder'
            ).sort((a, b) => {
              if (a.Priority === 'P0' && b.Priority !== 'P0') return -1;
              if (b.Priority === 'P0' && a.Priority !== 'P0') return 1;
              return a.number - b.number;
            });

            if (backlogReady.length > 0) {
              body += `Issues prontas para mover para Tonight (Builder, desbloqueadas):\n\n`;
              for (const item of backlogReady.slice(0, 5)) {
                body += `- [ ] #${item.number} ${item.title} (${item.Priority})\n`;
              }
              body += `\n_Marque as checkboxes e mova no board para programar execu√ß√£o noturna._\n`;
            } else {
              body += `_Nenhuma issue Builder no backlog pronta. Verificar se h√° Research/Architect tasks pendentes._\n`;
            }
            body += `\n`;

            body += `---\n_CEO Cockpit gerado automaticamente √†s ${now.toLocaleTimeString('pt-BR', { timeZone: 'America/Sao_Paulo' })} BRT_`;

            // Post to Issue #1
            const DIGEST_ISSUE = 1;
            try {
              await github.rest.issues.createComment({
                owner, repo,
                issue_number: DIGEST_ISSUE,
                body
              });
              console.log(`Cockpit report posted to issue #${DIGEST_ISSUE}`);
            } catch (e) {
              console.error(`Failed to post report: ${e.message}`);
              const { data: issue } = await github.rest.issues.create({
                owner, repo,
                title: 'CEO Cockpit ‚Äî Daily Digest',
                body: 'Issue pinada para receber CEO Cockpit reports di√°rios.\n\nCada dia √∫til √†s 06:00 BRT, um comment √© adicionado com o resumo completo.',
                labels: ['documentation']
              });
              await github.rest.issues.createComment({
                owner, repo,
                issue_number: issue.number,
                body
              });
              console.log(`Created new digest issue #${issue.number}`);
            }
